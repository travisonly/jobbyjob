<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Jobbyjob Lite+ — ATS Analyzer & Prompt Launcher (Local + Semantic)</title>

  <!-- Export to PDF (client-side only) -->
  <script defer src="https://cdnjs.cloudflare.com/ajax/libs/html2pdf.js/0.10.1/html2pdf.bundle.min.js"></script>

  <style>
    :root{
      --bg: #0b1020;
      --card:#0f172a;
      --text:#e5e7eb;
      --muted:#94a3b8;
      --brand:#8b5cf6;
      --brand-2:#22c55e;
      --danger:#ef4444;
      --warn:#eab308;
      --ok:#22c55e;
      --border:#1f2937;
      --chip:#111827;
      --chip-text:#cbd5e1;
    }
    *{box-sizing:border-box}
    body{
      margin:0;
      font-family: ui-sans-serif,system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial,Apple Color Emoji,Segoe UI Emoji;
      background: radial-gradient(1200px 800px at 10% 10%, #141a34 0%, #0b1020 50%, #090d1a 100%);
      color: var(--text);
      min-height:100vh;
    }
    .container{max-width:1200px;margin:0 auto;padding:24px}
    header{display:flex;gap:16px;align-items:center;justify-content:space-between;margin-bottom:16px}
    h1{font-size:28px;margin:0;font-weight:800;letter-spacing:.2px}
    .sub{color:var(--muted);font-size:14px;margin-top:4px}
    .row{display:grid;grid-template-columns:1fr 1fr;gap:16px}
    @media (max-width: 900px){.row{grid-template-columns:1fr}}
    .card{
      background:var(--card);
      border:1px solid var(--border);
      border-radius:16px;
      padding:16px;
      box-shadow:0 10px 30px rgba(0,0,0,.25), inset 0 1px 0 rgba(255,255,255,.03);
    }
    .card h2{margin:0 0 8px 0;font-size:16px;font-weight:700}
    .bar{display:flex;gap:8px;align-items:center;justify-content:space-between;margin-bottom:8px}
    .btn{
      background:linear-gradient(135deg, #7c3aed, #4f46e5);
      border:none;color:white;border-radius:10px;
      padding:10px 14px;cursor:pointer;font-weight:700;font-size:14px;
      box-shadow:0 8px 20px rgba(99,102,241,.35);
    }
    .btn:disabled{opacity:.55;cursor:not-allowed}
    .btn.secondary{background:#0b1227;border:1px solid #27304a;box-shadow:none;color:#c7d2fe}
    .btn.ghost{background:transparent;border:1px solid #293146;color:#cbd5e1}
    .btn.green{background:linear-gradient(135deg, #22c55e, #16a34a); box-shadow:0 8px 20px rgba(34,197,94,.35)}
    .btn.warn{background:linear-gradient(135deg, #f59e0b, #d97706)}
    .split{display:flex;gap:8px;flex-wrap:wrap}
    textarea{
      width:100%;min-height:320px;resize:vertical;border-radius:12px;padding:12px 14px;
      background:#0b1227;border:1px solid #27304a;color:#e5e7eb;font-family:ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,monospace;font-size:13px;line-height:1.5;
    }
    textarea:focus{outline:none;border-color:#4f46e5}
    .counter{color:var(--muted);font-size:12px;margin-top:6px}
    .scores{
      display:grid;grid-template-columns:repeat(4,minmax(0,1fr));gap:12px;margin:12px 0;
    }
    @media (max-width: 900px){.scores{grid-template-columns:repeat(2,minmax(0,1fr))}}
    .score{
      background:#0b1227;border:1px solid #27304a;border-radius:14px;padding:14px;text-align:center;
    }
    .score .n{font-size:32px;font-weight:900;margin-bottom:4px}
    .excellent{color:var(--ok)} .good{color:var(--warn)} .poor{color:var(--danger)}
    .label{font-size:12px;color:var(--muted)}
    .issues,.keywords,.prompts{margin-top:10px}
    .issues h3,.keywords h3,.prompts h3{margin:0 0 8px 0;font-size:15px}
    .list{
      background:#0b1227;border:1px solid #27304a;border-radius:12px;padding:12px;
    }
    .list ul{margin:0;padding-left:18px}
    .chipbox{display:flex;gap:8px;flex-wrap:wrap}
    .chip{
      background:var(--chip);
      border:1px solid #1f2937;
      color:var(--chip-text);
      padding:6px 10px;border-radius:999px;font-size:12px;font-weight:700;
    }
    .chip.pos{border-color:#14532d;background:#052e17;color:#86efac}
    .chip.neg{border-color:#4c0519;background:#2a0a12;color:#fda4af}
    .grid2{display:grid;grid-template-columns:1fr 1fr;gap:12px}
    @media (max-width: 900px){.grid2{grid-template-columns:1fr}}
    pre.prompt{
      background:#0b1227;border:1px solid #27304a;color:#e5e7eb;border-radius:12px;padding:12px;white-space:pre-wrap;word-wrap:break-word;max-height:420px;overflow:auto;font-size:12px;
    }
    .topbar{display:flex;gap:8px;align-items:center;flex-wrap:wrap}
    .switch{display:inline-flex;align-items:center;gap:8px;color:#cbd5e1}
    .switch input{appearance:none;width:42px;height:24px;background:#1f2937;border-radius:999px;position:relative;cursor:pointer;outline:none;transition:.2s}
    .switch input:checked{background:#16a34a}
    .switch input:before{content:"";position:absolute;top:3px;left:3px;width:18px;height:18px;background:#fff;border-radius:50%;transition:.2s}
    .switch input:checked:before{left:21px}
    .progress{height:8px;background:#0b1227;border:1px solid #27304a;border-radius:999px;overflow:hidden}
    .progress > div{height:8px;background:linear-gradient(90deg,#4f46e5,#22c55e);width:0%}
    footer{margin:24px 0 8px;color:#64748b;font-size:12px;text-align:center}
    .toast{
      position:fixed;right:16px;bottom:16px;background:#052e17;color:#86efac;border:1px solid #14532d;
      padding:10px 14px;border-radius:10px;font-weight:700;box-shadow:0 10px 30px rgba(0,0,0,.25);display:none
    }
  </style>
</head>
<body>
  <div class="container">
    <header>
      <div>
        <h1>Jobbyjob Lite+</h1>
        <div class="sub">ATS resume analysis, keyword gap, and AI prompt launcher — client-side, free. (Semantic on by default)</div>
      </div>
      <div class="topbar">
        <label class="switch">
          <input id="darkToggle" type="checkbox" checked />
          <span>Dark mode</span>
        </label>
        <button class="btn ghost" id="exportBtn">Export PDF</button>
        <button class="btn ghost" id="clearBtn">Clear</button>
      </div>
    </header>

    <div class="row">
      <div class="card">
        <div class="bar">
          <h2>Your Resume</h2>
          <div class="split">
            <label class="btn secondary">
              Upload
              <input id="resumeFile" type="file" accept=".txt,.pdf,.doc,.docx" hidden />
            </label>
            <span class="counter"><span id="resumeCount">0</span> words</span>
          </div>
        </div>
        <textarea id="resume" placeholder="Paste your resume..."></textarea>
      </div>

      <div class="card">
        <div class="bar">
          <h2>Job Description</h2>
          <div class="split">
            <label class="btn secondary">
              Upload
              <input id="jdFile" type="file" accept=".txt,.pdf,.doc,.docx" hidden />
            </label>
            <span class="counter"><span id="jdCount">0</span> words</span>
          </div>
        </div>
        <textarea id="jd" placeholder="Paste the job description..."></textarea>
      </div>
    </div>

    <div class="card">
      <div class="bar">
        <div class="split">
          <button class="btn green" id="analyzeBtn">Analyze</button>
          <button class="btn" id="reanalyzeBtn" disabled>Reanalyze</button>
        </div>
        <div style="min-width:220px">
          <div class="progress"><div id="progressFill"></div></div>
        </div>
      </div>
      <div id="results"></div>
    </div>

    <div class="card prompts" id="promptsCard" style="display:none">
      <div class="bar">
        <h2>AI Optimization Prompts</h2>
        <div class="split">
          <button class="btn secondary" id="copyResumePrompt">Copy Resume Prompt</button>
          <button class="btn secondary" id="copyCoverPrompt">Copy Cover Prompt</button>
        </div>
      </div>
      <div class="grid2">
        <div>
          <h3>Resume Optimization</h3>
          <pre id="resumePrompt" class="prompt"></pre>
        </div>
        <div>
          <h3>Cover Letter</h3>
          <pre id="coverPrompt" class="prompt"></pre>
        </div>
      </div>
    </div>

    <footer>Local + semantic (Hugging Face MiniLM). No sign-ups, no keys, no tracking.</footer>
  </div>

  <div id="toast" class="toast">Copied to clipboard</div>

  <script>
    /* -------------------------
       STATE & ELEMENTS
    ------------------------- */
    let resumeText = localStorage.getItem('resumeText') || '';
    let jdText = localStorage.getItem('jdText') || '';
    let analysis = null;

    const resumeEl = document.getElementById('resume');
    const jdEl = document.getElementById('jd');
    const resumeCount = document.getElementById('resumeCount');
    const jdCount = document.getElementById('jdCount');
    const analyzeBtn = document.getElementById('analyzeBtn');
    const reanalyzeBtn = document.getElementById('reanalyzeBtn');
    const resultsEl = document.getElementById('results');
    const progressFill = document.getElementById('progressFill');
    const promptsCard = document.getElementById('promptsCard');
    const resumePromptEl = document.getElementById('resumePrompt');
    const coverPromptEl = document.getElementById('coverPrompt');
    const copyResumePromptBtn = document.getElementById('copyResumePrompt');
    const copyCoverPromptBtn = document.getElementById('copyCoverPrompt');
    const toastEl = document.getElementById('toast');

    /* -------------------------
       INIT
    ------------------------- */
    resumeEl.value = resumeText;
    jdEl.value = jdText;
    updateCount(resumeText, resumeCount);
    updateCount(jdText, jdCount);
    enableAnalyze();

    document.getElementById('darkToggle').addEventListener('change', (e)=>{
      document.body.style.background = e.target.checked
        ? 'radial-gradient(1200px 800px at 10% 10%, #141a34 0%, #0b1020 50%, #090d1a 100%)'
        : '#f3f4f6';
    });

    window.addEventListener('beforeunload', ()=>{
      localStorage.setItem('resumeText', resumeEl.value);
      localStorage.setItem('jdText', jdEl.value);
    });

    resumeEl.addEventListener('input', e => {
      resumeText = e.target.value;
      updateCount(resumeText, resumeCount);
      enableAnalyze();
    });
    jdEl.addEventListener('input', e => {
      jdText = e.target.value;
      updateCount(jdText, jdCount);
      enableAnalyze();
    });

    document.getElementById('resumeFile').addEventListener('change', (e)=> handleFile(e, resumeEl, resumeCount));
    document.getElementById('jdFile').addEventListener('change', (e)=> handleFile(e, jdEl, jdCount));

    function updateCount(text, el){
      const words = (text.trim().match(/\b[\w'-]+\b/g) || []).length;
      el.textContent = words;
    }
    function enableAnalyze(){
      analyzeBtn.disabled = !(resumeEl.value.trim() && jdEl.value.trim());
      reanalyzeBtn.disabled = !analysis;
    }
    function setProgress(pct){
      progressFill.style.width = Math.max(0, Math.min(100, pct)) + '%';
    }

    /* -------------------------
       FILE PARSERS (lazy)
    ------------------------- */
    async function handleFile(e, targetTextarea, counterEl){
      const file = e.target.files[0];
      if(!file) return;
      setProgress(5);
      const ext = (file.name.split('.').pop()||'').toLowerCase();
      try{
        let text = '';
        if(ext === 'pdf'){
          await ensurePdfJs();
          text = await extractPDF(file);
        }else if(ext === 'docx'){
          await ensureMammoth();
          text = await extractDOCX(file);
        }else{
          text = await file.text();
        }
        targetTextarea.value = text;
        if(targetTextarea === resumeEl) resumeText = text; else jdText = text;
        updateCount(text, counterEl);
        enableAnalyze();
        setProgress(0);
      }catch(err){
        alert('Error reading file: ' + err.message);
        setProgress(0);
      }
    }

    async function ensurePdfJs(){
      if(window.pdfjsLib) return;
      await loadScript('https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js');
      pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js';
    }
    async function ensureMammoth(){
      if(window.mammoth) return;
      await loadScript('https://cdnjs.cloudflare.com/ajax/libs/mammoth/1.6.0/mammoth.browser.min.js');
    }
    function loadScript(src){
      return new Promise((resolve, reject)=>{
        const s = document.createElement('script');
        s.src = src; s.onload = resolve; s.onerror = reject;
        document.head.appendChild(s);
      });
    }
    async function extractPDF(file){
      const buf = await file.arrayBuffer();
      const pdf = await pdfjsLib.getDocument({data: buf}).promise;
      let out = '';
      for(let i=1; i<=pdf.numPages; i++){
        const page = await pdf.getPage(i);
        const content = await page.getTextContent();
        out += content.items.map(t => t.str).join(' ') + '\n';
      }
      return out;
    }
    async function extractDOCX(file){
      const arrayBuffer = await file.arrayBuffer();
      const result = await mammoth.extractRawText({ arrayBuffer });
      return result.value || '';
    }

    /* -------------------------
       SEMANTIC SIMILARITY (Hugging Face public endpoint)
       No key required; graceful fallback on failure.
    ------------------------- */
    async function getSemanticSimilarity(textA, textB){
      // Short-circuit for tiny inputs
      if(!textA || !textB || textA.length < 200 || textB.length < 200) return 0;

      const payload = {
        inputs: {
          source_sentence: textA.slice(0, 20000),
          sentences: [textB.slice(0, 20000)]
        }
      };

      const controller = new AbortController();
      const timeout = setTimeout(() => controller.abort(), 4500); // 4.5s safety timeout

      try{
        const res = await fetch(
          "https://api-inference.huggingface.co/models/sentence-transformers/all-MiniLM-L6-v2",
          {
            method:"POST",
            headers:{ "Content-Type":"application/json" },
            body: JSON.stringify(payload),
            signal: controller.signal
          }
        );
        clearTimeout(timeout);
        const data = await res.json();
        // Expected: [similarityScoreFloat]
        if(Array.isArray(data) && typeof data[0] === "number"){
          return Math.round(Math.max(0, Math.min(100, data[0] * 100)));
        }
        // HF may warm the model; try again once quickly if it returns object
        if(data && data.error && /loading|please try again/i.test(data.error)){
          await new Promise(r => setTimeout(r, 800));
          return getSemanticSimilarity(textA, textB);
        }
        return 0;
      }catch(e){
        // Abort or network error -> fallback to 0
        return 0;
      }
    }

    /* -------------------------
       ANALYSIS (ATS-style)
    ------------------------- */
    analyzeBtn.addEventListener('click', analyze);
    reanalyzeBtn.addEventListener('click', analyze);

    async function analyze(){
      setProgress(12);
      // Run local analysis first (fast), then semantic (slow, optional)
      analysis = performAnalysisLocal(resumeEl.value, jdEl.value);
      renderResults(analysis);
      buildPrompts(analysis);
      promptsCard.style.display = 'block';
      setProgress(55);

      // Blend in semantic score (if available) to make overall smarter
      const sem = await getSemanticSimilarity(resumeEl.value, jdEl.value); // 0-100
      if(sem > 0){
        // Recalculate overall: 75% local, 25% semantic
        analysis.scores.semantic = sem;
        analysis.scores.overall = Math.round(analysis.scores.overall * 0.75 + sem * 0.25);
        renderResults(analysis); // update UI
      }else{
        analysis.scores.semantic = 0;
      }
      setProgress(0);
      enableAnalyze();
    }

    // Stopwords & filler ignored for keyword gap
    const stopwords = new Set(("a,about,above,across,after,again,against,all,almost,alone,along,already,also,although,always,am,among,an,and,another,any,anyone,anything,are,around,as,at,be,because,been,before,being,below,between,both,but,by,can,could,did,do,does,doing,down,during,each,else,ever,every,for,from,further,had,has,have,having,he,her,here,hers,herself,him,himself,his,how,however,i,if,in,into,is,it,its,itself,just,least,less,like,may,me,might,more,most,mostly,my,myself,near,neither,no,nor,not,now,of,off,often,on,once,one,only,or,other,our,ours,ourselves,out,over,own,rather,really,same,she,should,since,so,some,someone,something,still,such,than,that,the,their,theirs,them,themselves,then,there,these,they,this,those,through,to,too,under,until,up,very,via,was,we,were,what,when,where,whether,which,while,who,whom,whose,why,will,with,within,without,would,you,your,yours,yourself,yourselves").split(','));
    const filler = new Set(("join,environment,role,including,etc,information,world,work,where").split(','));

    // Lightweight synonyms map (counts if any variant appears)
    const synonyms = {
      "program": ["program","programs","programmatic","initiative","initiatives"],
      "project": ["project","projects","pm","pmp","scrum","agile"],
      "marketing": ["marketing","brand","promotion","go-to-market","campaign","communications"],
      "communications": ["communications","comms","internal communications","external communications","pr","public relations"],
      "entrepreneurship": ["entrepreneurship","entrepreneurs","founders","startups"],
      "event": ["event","events","gala","conference","festival","logistics","cvent"],
      "invoice": ["invoice","invoicing","billing","ap","accounts payable","receivables"],
      "budget": ["budget","p&l","finance","financials","forecast"],
      "sponsor": ["sponsor","sponsors","sponsorship"],
      "database": ["crm","database","ux database","salesforce","hubspot","airtable"],
      "eoy": ["eoy","entrepreneur of the year"],
      "alumni": ["alumni","alumni programming"],
      "women": ["winning women","ww"],
      "ean": ["entrepreneurs access network","ean"]
    };

    function tokenize(text){
      return (text.toLowerCase().match(/\b[a-z][a-z+\-\/&]{2,}\b/g) || []);
    }

    function ngrams(tokens, n){
      const grams = [];
      for(let i=0;i<=tokens.length-n;i++){
        grams.push(tokens.slice(i,i+n).join(' '));
      }
      return grams;
    }

    function topTerms(text, limit=35){
      const tokens = tokenize(text).filter(w => !stopwords.has(w));
      const grams = [...tokens, ...ngrams(tokens,2), ...ngrams(tokens,3)];
      const freq = {};
      grams.forEach(t => {
        if (t.length < 4) return;
        const parts = t.split(' ');
        if (parts.every(p => filler.has(p))) return;
        freq[t] = (freq[t]||0)+1;
      });
      return Object.entries(freq).sort((a,b)=>b[1]-a[1]).slice(0,limit).map(([k])=>k);
    }

    function synonymHit(text){
      const low = text.toLowerCase();
      const hits = {};
      for(const canon in synonyms){
        hits[canon] = synonyms[canon].some(v => low.includes(v));
      }
      return hits;
    }

    function sectionize(text){
      const lines = text.split(/\r?\n/);
      const obj = { summary:'', skills:'', experience:'', education:'', certifications:'', other:'' };
      let current = 'other';
      for(const l of lines){
        const t = l.trim().toLowerCase();
        if(/^summary|objective|profile/.test(t)) current = 'summary';
        else if(/^skills|competencies|proficiencies/.test(t)) current = 'skills';
        else if(/^experience|employment|work history|professional experience/.test(t)) current = 'experience';
        else if(/^education|academic/.test(t)) current = 'education';
        else if(/^certifications?|licenses?/.test(t)) current = 'certifications';
        obj[current] += l + '\n';
      }
      return obj;
    }

    function extractBullets(text){
      return text.split(/\r?\n/)
        .map(l => l.trim())
        .filter(l => l && (
          /^[•\-\*\u2022]\s/.test(l) ||
          /^(led|managed|developed|created|implemented|improved|increased|decreased|built|designed|launched|achieved|delivered|coordinated|established|executed|optimized|spearheaded|reduced|generated|drove|directed|oversaw|owned|produced|facilitated|organized|maintained|supported)\b/i.test(l)
        ));
    }

    function hasMetric(line){
      return /(\+?\d{1,3}(,\d{3})*(\.\d+)?\s?(%|percent|pts|x|times|months?|years?|clients?|users?|employees?|students?|projects?)|\$[\d,]+|\b\d{3,}\b)/i.test(line);
    }

    function detectEntities(text){
      const titles = (text.match(/\b(Director|Manager|Coordinator|Consultant|Advisor|Lead|Analyst|Specialist|Producer)\b/gi) || []).length;
      const dates  = (text.match(/\b(0?[1-9]|1[0-2])\/\d{4}\b|\b(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Sept|Oct|Nov|Dec)\b\.?\s?\d{4}/gi) || []).length;
      const certs  = (text.match(/\b(PMP|CSM|PMI-ACP|Six Sigma|Scrum)\b/gi) || []).length;
      const degrees = (text.match(/\b(Bachelor|Master|Associate|B\.?S\.?|M\.?S\.?)\b/gi) || []).length;
      return { titles, dates, certs, degrees };
    }

    function readability(text){
      const sentences = Math.max(1, (text.match(/[.!?]+/g) || []).length);
      const words = Math.max(1, (text.match(/\b[\w'-]+\b/g) || []).length);
      const syllables = (text.toLowerCase().match(/[aeiouy]/g) || []).length;
      const score = 206.835 - (1.015 * (words / sentences)) - (84.6 * (syllables / words));
      return Math.round(Math.max(0, Math.min(100, score)));
    }

    function structuralPenalty(text){
      let bad = 0;
      if(/\|.+\|/.test(text)) bad++;        // looks like a table
      if(/ {2,}\w+ {2,}\w+/.test(text)) bad++; // multi-column spacing
      if(/header|footer/i.test(text)) bad++;
      return Math.max(0, 100 - bad*20);
    }

    function performAnalysisLocal(resume, jd){
      const out = { scores:{}, issues:[], keywords:{matched:[], missing:[]}, bullets:{total:0, withMetrics:0, weak:[]}, note:'' };

      // Sections & weighting
      const sections = sectionize(resume);
      const weights = { summary:0.2, skills:0.3, experience:0.4, education:0.1 };

      // JD terms (phrase-heavy)
      const jdTop = topTerms(jd, 35);

      // Resume tokens by section
      const resumeTermsBySection = {};
      for(const s in sections){ resumeTermsBySection[s] = new Set(topTerms(sections[s], 60)); }

      // Weighted keyword score by section
      let denom = 0;
      const matchedSet = new Set();
      const missingList = [];

      jdTop.forEach(term=>{
        let termHit = false;
        for(const s in resumeTermsBySection){
          if(resumeTermsBySection[s].has(term)){
            // count once if found anywhere (score normalized later)
            termHit = true;
            matchedSet.add(term);
          }
        }
        if(!termHit && !filler.has(term)) missingList.push(term);
        denom += 1;
      });

      out.keywords.matched = Array.from(matchedSet);
      out.keywords.missing = missingList.slice(0,20);
      out.scores.keywords = denom ? Math.round((out.keywords.matched.length/denom)*100) : 0;

      // Synonym coverage (boost if core concepts present)
      const synHits = synonymHit(resume);
      const synBoost = Object.values(synHits).filter(Boolean).length >= 6 ? 5 : (Object.values(synHits).filter(Boolean).length >= 3 ? 3 : 0);
      out.scores.keywords = Math.min(100, out.scores.keywords + synBoost);

      // Bullets & metrics (experience only emphasis)
      const bullets = extractBullets(sections.experience || resume);
      const withMetrics = bullets.filter(hasMetric);
      out.bullets.total = bullets.length;
      out.bullets.withMetrics = withMetrics.length;
      out.bullets.weak = bullets.filter(b => !hasMetric(b)).slice(0, 6);
      const quantifiedScore = bullets.length ? Math.round((withMetrics.length / bullets.length) * 100) : 0;
      out.scores.quantified = quantifiedScore;
      if (quantifiedScore < 60 && bullets.length >= 6){
        out.issues.push(`Only ${quantifiedScore}% of bullets include metrics`);
      }

      // Section presence score
      const presence = {
        summary: !!sections.summary.trim(),
        skills: !!sections.skills.trim(),
        experience: !!sections.experience.trim(),
        education: !!sections.education.trim()
      };
      const presentCount = Object.values(presence).filter(Boolean).length;
      out.scores.structure = Math.round((presentCount / 4) * 100);

      // Entities (confidence)
      const ents = detectEntities(resume);
      let entityScore = 60;
      if(ents.titles) entityScore += 10;
      if(ents.dates) entityScore += 10;
      if(ents.certs) entityScore += 10;
      if(ents.degrees) entityScore += 10;
      entityScore = Math.min(100, entityScore);

      // Readability & formatting
      out.scores.readability = readability(resume);
      out.scores.format = structuralPenalty(resume);

      // Overall ATS-style weighting (local-only first)
      out.scores.overall = Math.round(
        (out.scores.keywords * 0.45) +
        (out.scores.quantified * 0.20) +
        (out.scores.structure * 0.10) +
        (entityScore * 0.10) +
        (out.scores.readability * 0.10) +
        (out.scores.format * 0.05)
      );

      // High missing list? Flag once (ignoring filler)
      if (out.keywords.missing.length >= 10){
        out.issues.push(`Missing ${out.keywords.missing.length} key JD terms`);
      }
      return out;
    }

    function cls(score){
      return score >= 80 ? 'excellent' : score >= 60 ? 'good' : 'poor';
    }
    function escapeHtml(s){
      return s.replace(/[&<>"']/g, m=>({ '&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#039;' }[m]));
    }

    function renderResults(a){
      resultsEl.innerHTML = `
        <div class="scores">
          <div class="score">
            <div class="n ${cls(a.scores.overall)}">${a.scores.overall}</div>
            <div class="label">Overall</div>
          </div>
          <div class="score">
            <div class="n ${cls(a.scores.keywords)}">${a.scores.keywords}%</div>
            <div class="label">Keyword Match</div>
          </div>
          <div class="score">
            <div class="n ${cls(a.scores.quantified)}">${a.scores.quantified}%</div>
            <div class="label">Bullets w/ Metrics (${a.bullets.withMetrics}/${a.bullets.total})</div>
          </div>
          <div class="score">
            <div class="n ${cls(a.scores.structure)}">${a.scores.structure}%</div>
            <div class="label">Structure</div>
          </div>
        </div>

        ${typeof a.scores.semantic === 'number' ? `
          <div class="scores" style="margin-top:0">
            <div class="score">
              <div class="n ${cls(a.scores.semantic)}">${a.scores.semantic}%</div>
              <div class="label">Semantic Match (HF)</div>
            </div>
          </div>` : ''}

        ${a.issues.length ? `
        <div class="issues">
          <h3>Priority Issues (${a.issues.length})</h3>
          <div class="list">
            <ul>${a.issues.map(i=>`<li>${escapeHtml(i)}</li>`).join('')}</ul>
          </div>
        </div>`:''}

        <div class="keywords">
          <div class="grid2">
            <div>
              <h3>Matched Keywords (${a.keywords.matched.length})</h3>
              <div class="chipbox">
                ${a.keywords.matched.map(k=>`<span class="chip pos">${escapeHtml(k)}</span>`).join('') || '<span class="chip">None</span>'}
              </div>
            </div>
            <div>
              <h3>Add These Keywords (${a.keywords.missing.length})</h3>
              <div class="chipbox">
                ${a.keywords.missing.map(k=>`<span class="chip neg">${escapeHtml(k)}</span>`).join('') || '<span class="chip">None</span>'}
              </div>
            </div>
          </div>
        </div>

        ${a.bullets.weak.length ? `
        <div class="issues" style="margin-top:12px">
          <h3>Bullets Needing Metrics (${a.bullets.weak.length} shown)</h3>
          <div class="list">
            <ul>${a.bullets.weak.map(b=>`<li>${escapeHtml(b)}</li>`).join('')}</ul>
          </div>
        </div>`:''}
      `;
    }

    /* -------------------------
       PROMPTS & CLIPBOARD
    ------------------------- */
    function buildPrompts(a){
      const resumePrompt = `You are an expert ATS resume optimizer. Rewrite this resume to maximize ATS compatibility and mirror the job description.

RESUME:
${resumeEl.value}

JOB DESCRIPTION:
${jdEl.value}

SCORES:
- Overall: ${a.scores.overall}/100
- Keyword Match: ${a.scores.keywords}%
- Bullets with metrics: ${a.scores.quantified}%
${typeof a.scores.semantic === 'number' ? `- Semantic Match: ${a.scores.semantic}%` : ''}

PRIORITY ISSUES:
${a.issues.map(i => `• ${i}`).join('\n')}

MISSING KEYWORDS (use naturally, avoid filler):
${a.keywords.missing.join(', ')}

ADD METRICS TO THESE BULLETS:
${(a.bullets.weak || []).map(b => `• ${b}`).join('\n')}

INSTRUCTIONS:
1) Include missing keywords naturally (no stuffing).
2) Convert weak bullets to quantified statements (%, $, #, time).
3) Strong action verbs; single-column, ATS-safe (no tables/columns).
4) Use MM/YYYY dates; clear section headers (SUMMARY, EXPERIENCE, EDUCATION, SKILLS, CERTS).
5) Output only the complete rewritten resume (no commentary).`;

      const coverPrompt = `Create a concise, professional cover letter tailored to this role.

JOB DESCRIPTION:
${jdEl.value}

CANDIDATE BACKGROUND (summary & notable outcomes):
${resumeEl.value.slice(0, 1800)}

STRUCTURE:
1) Hook with authentic interest in the brand and role.
2) Why I'm a fit: map skills to the JD (program ops, marketing, sponsors, internal/external comms).
3) 2–3 quantified achievements (%, $, #).
4) Close with a clear call to action and reference to resume.

TONE & LENGTH:
- Professional, confident, under 400 words.
- End with: "I thank you immensely for your time and consideration."`;

      resumePromptEl.textContent = resumePrompt;
      coverPromptEl.textContent = coverPrompt;

      copyResumePromptBtn.onclick = ()=> copyText(resumePromptEl.textContent, copyResumePromptBtn);
      copyCoverPromptBtn.onclick = ()=> copyText(coverPromptEl.textContent, copyCoverPromptBtn);
    }

    function showToast(msg='Copied to clipboard'){
      toastEl.textContent = msg;
      toastEl.style.display = 'block';
      setTimeout(()=> toastEl.style.display = 'none', 1500);
    }
    function copyText(t, btn){
      navigator.clipboard.writeText(t).then(()=>{
        if(btn){
          const prev = btn.textContent; btn.textContent = 'Copied!';
          setTimeout(()=>btn.textContent = prev, 1200);
        }
        showToast();
      });
    }

    /* -------------------------
       EXPORT & CLEAR
    ------------------------- */
    document.getElementById('exportBtn').addEventListener('click', ()=>{
      if(!analysis){
        alert('Run an analysis first.');
        return;
      }
      const report = document.createElement('div');
      report.innerHTML = `
        <h2 style="font-family:system-ui;margin:0 0 8px 0">Jobbyjob Lite+ Report</h2>
        <div style="font-family:system-ui;font-size:12px;color:#111;margin-bottom:8px">${new Date().toLocaleString()}</div>
        <hr/>
        <h3>Scores</h3>
        <ul>
          <li>Overall: ${analysis?.scores.overall ?? '-'} / 100</li>
          <li>Keyword Match: ${analysis?.scores.keywords ?? '-'}%</li>
          <li>Bullets with Metrics: ${analysis?.scores.quantified ?? '-'}%</li>
          <li>Structure: ${analysis?.scores.structure ?? '-' }%</li>
          <li>Readability: ${analysis?.scores.readability ?? '-' }%</li>
          <li>Formatting: ${analysis?.scores.format ?? '-' }%</li>
          ${typeof analysis?.scores.semantic === 'number' ? `<li>Semantic Match (HF): ${analysis.scores.semantic}%</li>` : ''}
        </ul>
        <h3>Matched Keywords (${analysis?.keywords.matched.length || 0})</h3>
        <p style="font-size:12px">${(analysis?.keywords.matched || []).join(', ')}</p>
        <h3>Missing Keywords (${analysis?.keywords.missing.length || 0})</h3>
        <p style="font-size:12px">${(analysis?.keywords.missing || []).join(', ')}</p>
        <h3>Bullets Needing Metrics</h3>
        <ul style="font-size:12px">${(analysis?.bullets.weak || []).map(b=>`<li>${escapeHtml(b)}</li>`).join('')}</ul>
      `;
      html2pdf().from(report).set({
        margin: 10,
        filename: 'jobbyjob-report.pdf',
        image: { type: 'jpeg', quality: 0.98 },
        html2canvas: { scale: 2 },
        jsPDF: { unit: 'mm', format: 'a4', orientation: 'portrait' }
      }).save();
    });

    document.getElementById('clearBtn').addEventListener('click', ()=>{
      if(!confirm('Clear text and results?')) return;
      resumeEl.value = '';
      jdEl.value = '';
      resumeText = jdText = '';
      updateCount('', resumeCount); updateCount('', jdCount);
      resultsEl.innerHTML = ''; promptsCard.style.display = 'none';
      analysis = null; enableAnalyze();
      localStorage.removeItem('resumeText'); localStorage.removeItem('jdText');
    });
  </script>

  <!-- Optional: Lazy parsers loaded dynamically when needed -->
  <script>
    // placeholders; actual libs are pulled on demand in ensurePdfJs/ensureMammoth
    window.pdfjsLib = window.pdfjsLib || undefined;
    window.mammoth = window.mammoth || undefined;
  </script>
</body>
</html>
